/**
 * ModelAdapter.ts
 * Core abstraction interface and implementations for AI model adapters.
 * Enables easy swapping and addition of different LLM providers.
 */

/**
 * Configuration object for recommendation generation
 */
export interface RecommendationConfig {
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  [key: string]: unknown;
}

/**
 * Interface for AI model adapters.
 * All model adapters must implement this interface to ensure compatibility
 * with the SpontaneityEngine.
 */
export interface IModelAdapter {
  /**
   * Generates a recommendation based on the provided prompt and configuration.
   * 
   * @param prompt - The user input or prompt to generate recommendations from
   * @param config - Optional configuration object for the generation (temperature, maxTokens, etc.)
   * @returns Promise resolving to a JSON string containing the recommendation
   */
  generateRecommendation(prompt: string, config?: RecommendationConfig): Promise<string>;
}

/**
 * Adapter for Google's Gemini AI model.
 * Implements IModelAdapter to integrate with SpontaneityEngine.
 */
export class GeminiAdapter implements IModelAdapter {
  private apiKey: string;

  /**
   * Creates a new GeminiAdapter instance.
   * 
   * @param apiKey - The Gemini API key for authentication
   */
  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('GeminiAdapter requires an API key');
    }
    this.apiKey = apiKey;
  }

  /**
   * Generates a recommendation using the Gemini API.
   * Currently returns a mock response for development.
   * 
   * @param prompt - The user input prompt
   * @param config - Optional configuration for generation
   * @returns Promise resolving to a JSON string with recommendation data
   */
  async generateRecommendation(
    prompt: string,
    config: RecommendationConfig = {}
  ): Promise<string> {
    try {
      // Simulate API call - replace with actual Gemini API integration
      // For now, returns mock JSON response
      const mockResponse = {
        model: 'gemini-pro',
        recommendation: `Gemini-generated recommendation for: "${prompt.substring(0, 50)}..."`,
        activities: [
          {
            name: 'Spontaneous Adventure',
            type: 'outdoor',
            duration: '2-3 hours',
            confidence: 0.85
          }
        ],
        reasoning: 'Generated by Gemini adapter (mock response)',
        config: config,
        timestamp: new Date().toISOString()
      };

      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 100));

      return JSON.stringify(mockResponse);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`GeminiAdapter error: ${errorMessage}`);
    }
  }
}

/**
 * Adapter for OpenAI's GPT models.
 * Implements IModelAdapter to integrate with SpontaneityEngine.
 */
export class OpenAIAdapter implements IModelAdapter {
  private apiKey: string;

  /**
   * Creates a new OpenAIAdapter instance.
   * 
   * @param apiKey - The OpenAI API key for authentication
   */
  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('OpenAIAdapter requires an API key');
    }
    this.apiKey = apiKey;
  }

  /**
   * Generates a recommendation using the OpenAI API.
   * Uses gpt-3.5-turbo for free tier compatibility.
   * 
   * @param prompt - The user input prompt
   * @param config - Optional configuration for generation
   * @returns Promise resolving to a JSON string with recommendation data
   */
  async generateRecommendation(
    prompt: string,
    config: RecommendationConfig = {}
  ): Promise<string> {
    try {
      // Build system prompt for structured JSON output
      const systemPrompt = `You are a spontaneous travel and activity recommendation assistant. 
Generate creative, local, and engaging micro-adventure suggestions based on user preferences.
Always respond with valid JSON in this exact structure:
{
  "title": "Short, engaging title (max 60 chars)",
  "recommendation": "1-2 sentence description of the activity",
  "description": "Detailed 2-3 sentence description of what the user will experience",
  "activities": [
    {
      "name": "Activity name",
      "type": "outdoor|indoor|mixed",
      "duration": "e.g., 1-2 hours, 30 min, half day",
      "description": "What they'll do"
    }
  ],
  "duration": "Total time estimate",
  "cost": "Budget-friendly|Free|Low cost|Moderate",
  "location": "Location context",
  "indoor_outdoor": "Indoor|Outdoor|Mixed",
  "group_friendly": true|false,
  "reasoning": "Why this fits their request"
}`;

      // Prepare messages for chat completion
      const messages = [
        { role: 'system' as const, content: systemPrompt },
        { role: 'user' as const, content: prompt }
      ];

      // API configuration - using gpt-3.5-turbo for free tier compatibility
      const requestBody = {
        model: 'gpt-3.5-turbo',
        messages: messages,
        temperature: config.temperature ?? 0.7,
        max_tokens: config.maxTokens ?? 800,
        top_p: config.topP ?? 1,
      };

      // Make API call to OpenAI
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          `OpenAI API error: ${response.status} ${response.statusText}. ${errorData.error?.message || ''}`
        );
      }

      const data = await response.json();
      
      // Extract the generated text from the response
      const generatedText = data.choices?.[0]?.message?.content;
      
      if (!generatedText) {
        throw new Error('No content generated by OpenAI');
      }

      // Try to parse as JSON (OpenAI should return JSON based on system prompt)
      try {
        const parsed = JSON.parse(generatedText);
        // Add metadata
        parsed.model = 'gpt-3.5-turbo';
        parsed.timestamp = new Date().toISOString();
        parsed.config = config;
        return JSON.stringify(parsed);
      } catch (parseError) {
        // If not valid JSON, wrap it in a structured format
        console.warn('OpenAI response was not valid JSON, wrapping:', parseError);
        const wrappedResponse = {
          model: 'gpt-3.5-turbo',
          title: 'Spontaneous Recommendation',
          recommendation: generatedText.trim(),
          description: generatedText.trim(),
          activities: [],
          duration: 'Varies',
          cost: 'Varies',
          location: 'Local',
          indoor_outdoor: 'Mixed',
          group_friendly: true,
          reasoning: 'Generated by OpenAI',
          timestamp: new Date().toISOString(),
          config: config,
          raw_response: generatedText
        };
        return JSON.stringify(wrappedResponse);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('OpenAIAdapter error:', errorMessage);
      throw new Error(`OpenAIAdapter error: ${errorMessage}`);
    }
  }
}

